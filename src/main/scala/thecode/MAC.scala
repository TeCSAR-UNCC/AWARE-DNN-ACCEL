// See LICENSE.txt for license details.
//Version1.2
//Implementing the Changes to  infer the DSPs using Xillinx Synthesis Tool(XST).This implementation might be tools specific. Please refer to the USER guide of the preffered Synthesis tool before you make changes to the code.
//We are infering the DSP48E2 slice available in the Ultrascale+ MPSOC.
//Previous version did infer the DSP blocks from the verilog code generated by verilator(after foracing the DSP MACRO) but the problem with that was that it would infer three DSPs for the single MAC block. 
//The reson for that was becuase we were using seperate assign statement for the doing the Multiplication (line number 29 ) and accumulation in (line number:34)This would evetnually generate two seperate wires for each of them.
//Refer to the schematic generated by the XST tool for older code.
//Changes
//The external interface of this module is being kept the same. But internal name changes are done in order to reflect the correct meaning of the signals.
//Name Changes: sum=>Accumulation,mul=>PartialAccum. 
// Logic Change: There is no actual change in the logic the change is only that we have removed two stage Multiplication and Accumulation to single stage.Line number 36.
//To map the DSP we are using the enable signal as the 'reset' signal from the DSP slice 
//To map  DSP we are using io.r siganl as Chip enable CE.
// Addditional register Final_Accumulation for registering the output('PartialAccum') as to reset the accumulator we are usoing the io.r signal and updating and reading the same PartialAccum signal would cause metastability issue. 
//Expected behaviour: The Mulitplied and accumulated output is present on the output after one clock cycle delay of input.


//This module does infer single DSP. but do we need to regiter the input ?? for better timming and probable support for DSP double pumping? as there is support for the input registering in the DSP48E2
package thecode
import chisel3.iotesters.{PeekPokeTester, Driver}
import chisel3._
//please! make enable a register
class MAC ( val Conv : Int)  extends Module 
{
    val io = IO(new Bundle {
    val enable = Input(Bool())
    val r = Input(Bool())
    val a = Input(Vec(Conv,UInt(8.W)))
    val b = Input(Vec(Conv,UInt(8.W)))
    val out = Output(UInt(16.W))
    })

	//val sum = RegInit(0.U(16.W))//Name changed
	//val Accumulation =RegInit(Vec(Seq.fill(Conv)(0.U(16.W)))
	val Accumulation =RegInit(0.U(16.W))
 	val Final_Accumulation = RegInit(0.U(16.W))

	

	val in1 =  Wire(Vec(Conv,UInt(8.W)))
	val in2 =  Wire(Vec(Conv,UInt(8.W)))


	//val PartialAccum = Wire(Vec((Conv,UInt(8.W)))
	val PartialAccum = Wire(UInt(16.W))
    	var tempaccum = 0.U
	//mul:=(in1*in2)+sum //Name changed

		 for(i<- 0 until Conv)
		{
		   tempaccum=tempaccum+(in1(i)*in2(i))     
		}
		PartialAccum:= tempaccum+Accumulation
		tempaccum=0.U


	when (io.enable) 
	{
		in1:=io.a
		in2:=io.b
		Accumulation := PartialAccum	
		
		
		
	}
	.otherwise
	{	
		
		 for(i<- 0 until Conv)
		{
			in1(i):=0.U
			in2(i):=0.U   
		}


	}

	when(io.r)
	{
		io.out :=Final_Accumulation

		Accumulation:=0.U
	}
	.otherwise
	{
		Final_Accumulation:=PartialAccum
		io.out := 0.U
	}

	
	
}


